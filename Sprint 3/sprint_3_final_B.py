"""
https://contest.yandex.ru/contest/23815/run-report/115811295/

Согласно условию, имеются данные вида: список списков.
Каждый подсписок содержит три элемента: строку, и два целых числа.
Цель: написать функцию, которая бы позволит отсортировать подсписки
в общем списке по значениям в подсписках – реализовать многоуровневую сортировку.
Дополнительное ограничение: реализация сортировки не может потреблять
O(n) дополнительной памяти для промежуточных данных.
Следовательно, необходимо использовать сортировку in-place.

Возьмем за основу алгоритм быстрой сортировки (quicksort),
работающий на основе принципа “разделяй и властвуй”.
Основная идея алгоритма быстрой сортировки заключается в том,
чтобы на каждой итерации выбрать “опорный элемент” (первый, последний, любой…).
Разделить массив на две части следующим образом:
    - массив перебирается поэлементно,
    - каждый элемент сравнивается с “опорным”,
    - все элементы, которые меньше или равны опорному отправляются в одну часть, остальные – в другую.
После разделения опорный элемент должен оказаться на “своем” месте.
Алгоритм рекурсивно применяется к подмассивам, которые получились после разделения.
Рекурсия продолжается до тех пор, пока подмассивы не станут настолько маленькими,
что их можно считать отсортированными.
Поскольку перемещение элементов происходит in-place,
элементы меняются местами, в результате мы получаем отсортированный массив.


-- ПРИНЦИП РАБОТЫ --
В функции quicksort происходит рекурсивный вызов функции quicksort
для левой и правой частей массива относительно опорного элемента,
пока массив не будет полностью отсортирован.

В функции partition происходит разделение массива на две части:
элементы, которые меньше опорного,
и элементы, которые больше или равны опорному.
Это разделение осуществляется путем перестановки элементов массива.

Для выполнения многоуровневой сортировки, чтобы упростить условие сравнения сортировки,
воспользуемся свойствами сравнения кортежей.
Кортежи неизменяемы, а потому не хранят дополнительную информацию, в отличие от списков,
и размещаются в памяти более компактно.

Кортежи можно отсортировать лексикографически сравнивая элементы поэлементно слева направо.
Поскольку штрафы и логины сравниваются по возрастанию, а число решенных задач
по убыванию, то, чтобы данные в кортежах поддерживали общий требуемый порядок сортировки,
изменим порядок элементов в кортеже и добавим минус для элемента "число решенных задач",
так как большие отрицательные значения будут идти раньше.

Превратим список [логин, число решенных задач, штраф]
в кортеж (-число решенных задач, штраф, логин).

Теперь, просто сравнивая кортежи поэлементно, выполняется условие:
- при сравнении двух участников выше будет идти тот, у которого решено больше задач;
- при равенстве числа решенных задач первым идет участник с меньшим штрафом;
- если число решенных задач и штрафы совпадают, то первым будет тот,
  у которого логин идет раньше в алфавитном (лексикографическом) порядке.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Массив будет отсортирован корректно, так как для каждой пары элементов
проверяется соответствие критериям многоуровневой сортировки.
Функция quicksort рекурсивно делит массив на меньшие подмассивы
и сортирует их, что обеспечивает корректную сортировку всего массива
и своевременное завершение работы массива.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
В среднем, время выполнения быстрой сортировки составляет O(n log n),
где n - количество элементов в массиве.
В худшем случае (если массив уже отсортирован или отсортирован в обратном порядке)
сложность существенно возрастает и может составлять O(n^2).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Пространственная сложность алгоритма составляет O(log n)
из-за рекурсивных вызовов функции quicksort, требующих места в стеке вызовов.
В дополнение к этому используется O(1) дополнительной памяти для временных переменных “при обмене”.

"""


def quicksort(arr, left, right):
    if left < right:

        pivot_index = partition(arr, left, right)

        quicksort(arr, left, pivot_index - 1)
        quicksort(arr, pivot_index + 1, right)


def partition(arr, left, right):
    pivot = arr[right]
    i = left - 1

    for j in range(left, right):
        if arr[j] < pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i + 1], arr[right] = arr[right], arr[i + 1]
    return i + 1


def multi_level_sort(arr):
    if not arr:
        return []
    quicksort(arr, 0, len(arr) - 1)
    return arr


def read_input():
    n = int(input().strip())
    datum = []
    while n > 0:

        line = input().strip().split()
        login = line[0]
        points = int(line[1])
        fine = int(line[2])
        temp = (-points, fine, login)
        datum.append(temp)
        n -= 1
    return datum


data = read_input()


sorted_data = multi_level_sort(data)
for item in sorted_data:
    print(item[2])
