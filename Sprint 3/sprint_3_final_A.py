"""
https://contest.yandex.ru/contest/23815/run-report/115641560/


Согласно условию, имеются данные (массив чисел), которые хранились в кольцевом буфере.
Массив был отсортирован по возрастанию.
При копировании данных из кольцевого буфера в обычный массив, сдвинулась “голова”.
То есть вместо одного отсортированного по возрастанию массива,
мы получили два отсортированных по возрастанию массива и “ступеньку” перехода
между максимальным и минимальным элементом массива (где “хвост” кольцевого буфера соединился с “головой”).

Цель: написать функцию, которая осуществляет поиск элемента
в “сломанном” массиве за O(log n) и возвращает индекс ячейки,
которая содержит искомый элемент.

Для решения поставленной задачи был реализован алгоритм поиска элемента в массиве
с использованием модифицированного бинарного поиска.
Основная идея алгоритма бинарного поиска заключается в том,
чтобы на каждом шаге отбрасывать часть данных, которые гарантированно не отвечают условию.
Возьмем эту идею за основу.

-- ПРИНЦИП РАБОТЫ --
Установим границы поиска: left на начало и right на конец массива.

Пока left меньше либо равен right, на каждой итерации цикла:
- находим условную середину массива mid;
- поскольку мы ориентируемся на алгоритм бинарного поиска,
  главным условием работы которого является то, что данные в массиве должны быть отсортированы,
  начнем с того, что поочередно будем проверять являются ли отсортированным
  подмассив в границах от left до mid и от mid до right;

- если элемент по индексу left меньше или равен элементу по индексу mid,
  значит левая часть массива отсортирована, иначе отсортирована правая часть массива;
	- в отсортированной части массива проверяем попадает ли в нее искомый элемент;
	- если попадает:
		- меняем границы поиска:
          устанавливаем значение right равным mid - 1, и таким образом отбрасываем часть массива;
- иначе:
    - меняем границы поиска:
      устанавливаем значение left равным mid + 1,и таким образом аналогично отбрасываем часть массива.

Таким образом мы в любом случае получаем ценную информацию:
- либо у нас есть отсортированная часть массива и в нее попадает нужный элемент,
  значит можно отбросить остальную часть массива

- либо у нас есть отсортированная часть массива и искомого элемента там нет,
  и значит эту часть массива также можно отбросить.

Если границы поиска “сошлись”, а искомый элемент не найден, возвращается -1.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Перед первым выполнением цикла, указали устанавливаются на нулевой и последний элемент массива.
На каждой итерации цикла происходит уменьшение диапазона поиска и контролируется,
что границы массива не вышли за пределы логики работы функции.
Это гарантирует наличие условия завершения работы алгоритма.
Предусмотрено условие, отсутствия искомого элемента в массиве, функция возвращает -1.


-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Временная сложность алгоритма составляет O(log n),
так как на каждой итерации поиска массив делится на две части и половина данных отбрасывается.
"""


def broken_search(nums, target) -> int:
    left = 0
    right = len(nums) - 1

    while left <= right:
        mid = (left + right) // 2

        if nums[mid] == target:
            return mid

        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1


def test():
    arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
    assert broken_search(arr, 5) == 6


test()
