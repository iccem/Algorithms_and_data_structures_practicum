'''
https://contest.yandex.ru/contest/24414/run-report/116234202/

-- ПРИНЦИП РАБОТЫ --
Реализована хеш-таблица с использованием метода цепочек для разрешения коллизий.
Хеш-таблица представлена списком заранее заданного размера,
в ячейках которого хранятся списки (цепочки) элементов.
По условиям задачи, поддерживать рехеширование и масштабирование хеш-таблицы не требуется,
поэтому следует тщательно подойти к выбору размера массива хеш-таблицы.

Для решения текущей задачи было выбрано число 100003 по следующим соображениям:
- по условию, количество ключей не может превышать 10ˆ5,
выбор размера 100003 позволяет хранить все ключи,
обеспечивая при этом низкую плотность заполнения таблицы.
Низкая плотность (или коэффициент заполнения) таблицы приводит к уменьшению числа коллизий
и повышает производительность операций поиска, вставки и удаления.
- при размере таблицы 100003 и максимальном количестве ключей 10ˆ5,
коэффициент заполнения составляет примерно 1.05, что позволяет поддерживать высокую производительность.
- выбранный размер предоставляет гибкость для небольшого увеличения количества элементов,
не требуя немедленного изменения размера таблицы.

Думается, также сдедует отметить недостаток сделанного выбора:
выбранный размер может оказаться избыточным для хранения менее 100000 ключей;
будет создано много пустых ячеек, а это неэффективно с точки зрения использования памяти.

Таблица поддерживает основные операции:
добавление (put), получение (get) и удаление (delete) элементов.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Корректность работы алгоритма обеспечивается использованием хеш-функции
для определения индекса ячейки, в которой должен храниться элемент.
Для разрешения коллизий применяется метод цепочек:
если несколько элементов имеют один и тот же хеш-индекс,
они сохраняются в связанный список в соответствующей ячейке.
При добавлении элемента алгоритм проверяет наличие ключа в списке и обновляет значение, если ключ уже существует.
При получении и удалении элемента алгоритм последовательно просматривает элементы списка
в соответствующей ячейке, что гарантирует корректность выполнения операций.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Операции добавления (put), получения (get) и удаления (delete) элемента
в среднем выполняются за O(1) благодаря равномерному распределению хеш-функции и небольшому размеру цепочек.
В худшем случае, при возникновении большого количества коллизий, временная сложность операций
может увеличиться до O(n), где n — количество элементов в таблице.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Пространственная сложность хеш-таблицы составляет O(n + m),
где n — размер массива таблицы, m — количество элементов в таблице.
Дополнительно используется память для хранения списков (цепочек) и элементов в них.
'''


class SimpleDict:
    def __init__(self):
        self.size = 100003
        self.table = [None] * self.size
        self.count = 0

    def _hash(self, key):
        return hash(key) % self.size

    def put(self, key, value):
        index = self._hash(key)
        if self.table[index] is None:
            self.table[index] = []
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                self.table[index][i] = (key, value)
                return
        self.table[index].append((key, value))
        self.count += 1

    def get(self, key):
        index = self._hash(key)
        if self.table[index] is None:
            return None

        for k, v in self.table[index]:
            if k == key:
                return v
        return None

    def delete(self, key):
        index = self._hash(key)
        temp = 0
        if self.table[index] is None:
            return None

        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                temp = self.table[index][i]
                del self.table[index][i]
                self.count -= 1
                return temp[1]
        return None


def read_input():
    n = int(input().strip())
    method_names = []
    d = SimpleDict()

    while n > 0:
        method_names.append(input().strip())
        n -= 1

    for line in method_names:
        i = line.split()
        try:
            method_name = i[0]
            if method_name in ['get', 'delete']:
                parameter = i[1]
                parameter = int(parameter)
                method = getattr(d, method_name)
                if method != None:
                    print(method(parameter))
                else:
                    print('None')
            elif method_name in ['put']:
                key, value = i[1], i[2]
                key = int(key)
                value = int(value)
                method = getattr(d, method_name)
                method(key, value)
        except (IndexError, OverflowError):
            print('error')


if __name__ == '__main__':
    read_input()
